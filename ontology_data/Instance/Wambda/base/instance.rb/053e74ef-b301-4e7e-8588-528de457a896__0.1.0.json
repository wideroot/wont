{
  "name": "instance",
  "uid": "053e74ef-b301-4e7e-8588-528de457a896",
  "version": "0.1.0",
  "path": "Instance/Wambda/base/instance.rb/053e74ef-b301-4e7e-8588-528de457a896__0.1.0.json",
  "frame": "Wambda",
  "accessors": {
    "wambda_path": "base/instance.rb",
    "ruby_code": "module Wont\n\n\nclass Instance\n  # TODO add this two class methods into frame\n  # (now load_base_from_code uses path from Instance before loading frame...,\n  # (however, something like class Instance; end require_module, will do the trick)\n  def self.frame\n    Frame\n    # note we assume that at some point require_wambda will be called before\n    # this method is called\n  end\n  def self.superframe\n    self == Instance ? nil : superclass\n  end\n  def frame\n    self.class\n  end\n\n\n  def initialize src, is_new: false\n    if src == nil\n      src = {\n        'uid'       => nil,\n        'version'   => \"0.0.0\",\n        'name'      => nil,\n        'accessors' => {},\n      }\n    end\n    # TODO add an extend mechanism\n    # src.extended [[method|mixin, uid]\n    # @_method_aliases {}\n\n    # index fields\n    @uid = src['uid']\n    @version = src['version'].split('.')\n    @name = src['name']\n\n    # @accessors[field] = value s.t. value.to_w? == value\n    @accessors = src['accessors']\n\n    # internal variables\n    @uid = nil if is_new\n    @updated = @new = uid == nil\n    warn inspect\n  end\n\n\n  def uid; @uid; end\n  def version; @version.join('.'); end\n  def name; @name; end\n  def name= name; @name = name; end\n  def major; @version[0]; end\n  def minor; @version[1]; end\n  def teeny; @version[2]; end\n\n  def inspect\n    char = '*' if updated?\n    char = 'N' if new?\n    \"<#{char}#{uid ? uid : 'nil'}_#{version} : #{frame}> #{@accessors}\"\n  end\n\n\n  def new_major!; @version[0] += 1; end\n  def new_minor!; @version[1] += 1; end\n\n\n  def new?      ; @new; end\n  def updated?  ; @updated; end\n\n\n  def valid?\n    # TODO names should be more restricted\n    # typecheck v with k...\n    name != nil && name.size > 0 && @accessors.all? { |_, v| v.valid? }\n  end\n\n  def valid!\n    raise \"invalid instance\" unless valid?\n  end\n\n\n  def clone\n    # TODO improve dup/clone\n    cloned = super\n    cloned.reset_uid!\n  end\n\n  def dup\n    clone\n  end\n\n\n  def save! recursive = false\n    if @updated\n      valid!\n      new_teeny\n      assign_uid!(recursive: true)\n      @accessors.map { |k,e| e.save!(recursive: recursive) } if recursive\n      Wont::add(internal_representation)\n      @updated = @new = false\n    end\n  end\n\n\n  def method_missing symbol, *args, &block\n    s = symbol.to_s\n    #warn \"method_missing: #{s}\"\n\n    # *__set\n    wid = accessor_symbol_setter(s)\n    if wid\n      if args.size != 1\n        raise ArgumentError, \"wrong number of arguments (#{args.size} for 1)\"\n      end\n      @updated = true\n      return @accessors[wid] = args.first\n    end\n\n    # *__get\n    wid = accessor_symbol_getter(s)\n    if wid && args.empty?\n      return @accessors[wid]\n    end\n\n    super\n  end\n\n  def respond_to? symbol, included_all = false\n    # TODO\n    super\n  end\n\n\n\n  def to_w; self; end\n\n\n\nprotected\n  def new_teeny!; @version[2] += 1; end\n\n\n  def internal_value\n    {'name' => name, 'uid' => uid, 'version' => version}\n  end\n\n  def attr_internal_value\n    InternalReference.new(self).attr_internal_value\n  end\n\n  def internal_representation\n    s = frame.to_s\n    fail \"#{self} frame is not Wont::...\" unless s.start_with? 'Wont::'\n    s = s['Wont::'.size .. -1]\n    i = internal_value\n    i['path']       = instance_path\n    i['frame']      = s\n    i['accessors']  = Hash[@accessors.map { |k,e| [k, e.attr_internal_value] }]\n    i\n  end\n\n\n\n  def instance_filename\n    \"#{uid}__#{version}.json\"\n  end\n\n  def instance_head_chain\n    [instance_filename, name]\n  end\n\n  def instance_tail_chain\n    chain = [frame]\n    while chain.last.superframe\n      chain << chain.last.superframe\n    end\n    chain\n  end\n\n  def instance_path_chain\n    instance_head_chain + instance_tail_chain\n  end\n\n  def instance_path\n    chain = instance_path_chain\n    File.join(chain.reverse.map { |i| i.to_s.rpartition(/::/).last })\n  end\n\n\n  def reset_uid!\n    @uid = nil\n    @updated = @new = true\n  end\n\n  def assign_uid! recursive = true\n    if recursive\n      @accessors.each { |k,e| e.assign_uid!(recursive: recursive) }\n    end\n    @uid = Wont::new_uid unless @uid\n  end\n\n\n\nprivate\n  def accessors_instances\n    @accessors.select { |attr| attr.is_a? Instance }\n  end\n\n  def accessor_symbol_getter string\n    string.extend(Chomps)\n    #puts \"asg #{string}: #{string.chomps('__get', '')}\"\n    Wont.get_wambda_id_from_string(string.chomps('__get', ''))\n  end\n\n  def accessor_symbol_setter string\n    string.extend(Chomps)\n    #puts \"ass #{string}: #{string.chomps('__set', '=')}\"\n    Wont.get_wambda_id_from_string(string.chomps('__set', '='))\n  end\n\n  module Chomps\n    # \\pre: postfix are ordered by desc length\n    def chomps(*postfixs)\n      postfixs.each do |postfix|\n        s = chomp(postfix)\n        return s if s.size != size || postfix.empty?\n      end\n      nil\n    end\n  end\nend\n\n\n  def self.internal_representation_instance name: nil, version: nil, accessors: {}\n    version = \"0.0.0\" unless version\n    { 'uid'       => nil,\n      'name'      => name,\n      'version'   => version,\n      'accessors' => accessors,\n    }\n  end\n\n\nend\n\n\nclass Hash\n  def to_ii name = nil, version = nil\n    Wont::internal_representation_instance(\n      name:       name,\n      version:    version,\n      accessors:  self,\n    )\n  end\nend\n\n# TODO \n# create frames usin an object as prototype\n# include, extend, class methods, instance methods, singleton methods...\n# static type...\n"
  }
}